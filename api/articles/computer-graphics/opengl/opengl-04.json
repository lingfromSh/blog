{"title":"OpenGL - Hello, Triangle","uid":"68f0bef26795408fddf21d88ca9001c0","slug":"computer-graphics/opengl/opengl-04","date":"2022-08-07T13:37:47.000Z","updated":"2022-08-16T08:21:58.286Z","comments":true,"path":"api/articles/computer-graphics/opengl/opengl-04.json","keywords":null,"cover":[],"content":"<h1 id=\"OpenGL-Hello-Triangle\"><a href=\"#OpenGL-Hello-Triangle\" class=\"headerlink\" title=\"OpenGL - Hello, Triangle\"></a>OpenGL - Hello, Triangle</h1><p>所有东西在OpenGL内都是三维的, 但是屏幕或窗口是2d的。所以所有坐标都需要由3D转为2D坐标。这个转换过程成为管线(pipeline)。这里面分为两大步，第一步坐标转换，第二步将坐标转为像素点绘图。</p>\n<p>这些步骤都是高度分化的，所以很容易并行执行。GPU有很多的小单元所以很适合去并行执行这些任务，这些小单元上运行的程序则称为shader(着色器)。</p>\n<p>着色器用GLSL控制。</p>\n<h2 id=\"Pipelines\"><a href=\"#Pipelines\" class=\"headerlink\" title=\"Pipelines\"></a>Pipelines</h2><p>Vertex Data -&gt; Shape Assembly -&gt; Geometry Shader -&gt; Rasterization(光栅化) -&gt; Fragment Shader -&gt; Test and Blending</p>\n<h2 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h2><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">\n#include &lt;glad&#x2F;glad.h&gt;\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\n#include &lt;iostream&gt;\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height);\nvoid process_keyboard_input(GLFWwindow *window);\n\n&#x2F;&#x2F; shader written in GLSL\nconst char *vertexShaderSource &#x3D; &quot;#version 330 core\\n&quot;\n                                 &quot;layout (location &#x3D; 0) in vec3 aPos;\\n&quot;\n                                 &quot;void main()\\n&quot;\n                                 &quot;&#123;\\n&quot;\n                                 &quot;   gl_Position &#x3D; vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;\n                                 &quot;&#125;\\0&quot;;\n\nconst char *fragmentShaderSource &#x3D; &quot;#version 330 core\\n&quot;\n                                   &quot;out vec4 FragColor;\\n&quot;\n                                   &quot;void main()\\n&quot;\n                                   &quot;&#123;\\n&quot;\n                                   &quot;    FragColor &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot;\n                                   &quot;&#125;\\0&quot;;\n\nint main(void)\n&#123;\n\n    &#x2F;&#x2F; 初始化glfw\n    GLFWwindow *window;\n    int w_width &#x3D; 1920, w_height &#x3D; 1080;\n\n    if (!glfwInit())\n    &#123;\n        std::cout &lt;&lt; &quot;failed to init glfw&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;\n\n    window &#x3D; glfwCreateWindow(1920, 1080, &quot;cube&quot;, NULL, NULL);\n    if (!window)\n    &#123;\n        std::cout &lt;&lt; &quot;failed to create window&quot; &lt;&lt; std::endl;\n        glfwTerminate();\n        return -1;\n    &#125;\n\n    &#x2F;&#x2F; 创建上下文\n    glfwMakeContextCurrent(window);\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    &#123;\n        std::cout &lt;&lt; &quot;failed to init glad&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;\n\n    &#x2F;******************************\n              shader part\n    *******************************&#x2F; \n\n    &#x2F;&#x2F; vertex shader\n    unsigned int vertexShader;\n    vertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER);\n    &#x2F;&#x2F; 编译Vertex shader\n    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);\n    glCompileShader(vertexShader);\n\n    &#x2F;&#x2F; fragment shader\n    unsigned int fragmentShader;\n    fragmentShader &#x3D; glCreateShader(GL_FRAGMENT_SHADER);\n    &#x2F;&#x2F; 编译Fragment shader\n    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);\n    glCompileShader(fragmentShader);\n\n    &#x2F;&#x2F; shader\n    unsigned int shaderProgram;\n    shaderProgram &#x3D; glCreateProgram();\n    glAttachShader(shaderProgram, vertexShader);\n    glAttachShader(shaderProgram, fragmentShader);\n    glLinkProgram(shaderProgram);\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    &#x2F;***********************\n          triangle part\n    ***********************&#x2F;\n\n    &#x2F;&#x2F; 定义三角形顶点\n    float vertexArray[] &#x3D; &#123;\n        0.5, -0.5, 0,\n        -0.5, -0.5, 0,\n        0, 0.5, 0,\n    &#125;;\n\n    &#x2F;&#x2F; 存储分配到的id\n    unsigned int VBO, VAO;\n    glGenVertexArrays(1, &amp;VAO);\n    glGenBuffers(1, &amp;VBO);\n\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexArray), vertexArray, GL_STATIC_DRAW);\n\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0); \n\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;&#x2F; 处理键盘事件\n        process_keyboard_input(window);\n\n        glClearColor(0.2, 0.4, 0.6, 1.0);\n\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;&#x2F; use our shader program when we want to render an object\n        glUseProgram(shaderProgram); &#x2F;&#x2F; 不使用，则上默认色\n        glBindVertexArray(VAO);\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n\n        glfwSwapBuffers(window);\n\n        glfwPollEvents();\n    &#125;\n\n    glDeleteVertexArrays(1, &amp;VAO);\n    glDeleteBuffers(1, &amp;VBO);\n    glDeleteProgram(shaderProgram);\n\n    glfwTerminate();\n    return 0;\n&#125;\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height)\n&#123;\n    glfwMakeContextCurrent(window);\n    glViewport(0, 0, width, height);\n&#125;\n\nvoid process_keyboard_input(GLFWwindow *window)\n&#123;\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS)\n    &#123;\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"结果截图\"><a href=\"#结果截图\" class=\"headerlink\" title=\"结果截图\"></a>结果截图</h2><p><img src=\"computer-graphics/opengl/opengl-04/result.png\" alt=\"img\"></p>\n","text":"OpenGL - Hello, Triangle所有东西在OpenGL内都是三维的, 但是屏幕或窗口是2d的。所以所有坐标都需要由3D转为2D坐标。这个转换过程成为管线(pipeline)。这里面分为两大步，第一步坐标转换，第二步将坐标转为像素点绘图。 这些步骤都是高度分化的，所...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"ComputerGraphics","slug":"ComputerGraphics","count":5,"path":"api/tags/ComputerGraphics.json"},{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"},{"name":"C++","slug":"C","count":4,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#OpenGL-Hello-Triangle\"><span class=\"toc-text\">OpenGL - Hello, Triangle</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pipelines\"><span class=\"toc-text\">Pipelines</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">编写代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%9C%E6%88%AA%E5%9B%BE\"><span class=\"toc-text\">结果截图</span></a></li></ol></li></ol>","author":{"name":"Stephen Ling","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Think twice, code once!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"小表驱动大表","uid":"9340bb342c42221aa9c7ffe9155e75d9","slug":"database/less-drive-more","date":"2022-08-12T02:38:58.000Z","updated":"2022-08-16T08:21:58.290Z","comments":true,"path":"api/articles/database/less-drive-more.json","keywords":null,"cover":null,"text":"小表驱动大表什么是小表驱动大表?用小的数据集去驱动(匹配)大的数据集 为什么需要小表驱动大表 小表驱动大表 select *from tb_emp_bigdata A where A.deptno in (select B.deptno from tb_dept_bigdata ...","link":"","photos":[],"count_time":{"symbolsCount":391,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"SQL","slug":"SQL","count":1,"path":"api/tags/SQL.json"}],"author":{"name":"Stephen Ling","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Think twice, code once!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"OpenGL - Creating a window","uid":"28d97a9714322db76ed5f13f13ad12ec","slug":"computer-graphics/opengl/opengl-03","date":"2022-08-07T08:46:26.000Z","updated":"2022-08-16T08:21:58.286Z","comments":true,"path":"api/articles/computer-graphics/opengl/opengl-03.json","keywords":null,"cover":[],"text":"Creating a window创建窗口是第一步，然而OpenGL仅仅是定义了一系列关于窗口的操作api，而这些操作api实际执行和操作系统和硬件都有很大关系。这也意味着开发者必须自己处理这些问题。 不过，幸运的是我们可以使用一些库来避免自己处理这些问题。例如GLUT,GLFW...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"ComputerGraphics","slug":"ComputerGraphics","count":5,"path":"api/tags/ComputerGraphics.json"},{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"},{"name":"C++","slug":"C","count":4,"path":"api/tags/C.json"}],"author":{"name":"Stephen Ling","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Think twice, code once!","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}