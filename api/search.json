[{"id":"83066c213681d7c0562fe9e2855829f7","title":"BPMN 业务处理流程建模 - 信号启动事件 vs 消息启动事件","content":"信号启动事件 vs 消息启动事件\n\n\n\n\n\n\n\n\nMain difference between message and signal event:https://forum.camunda.io/t/main-difference-between-message-and-signal-event/19610/2\n一句话来说, 信号是广播事件而消息是一对一事件\n","slug":"bpmn-diff-between-signal-and-message","date":"2022-08-17T07:01:25.000Z","categories_index":"","tags_index":"BPMN","author_index":"Stephen Ling"},{"id":"474279e40782d5e65040b33afbc3267c","title":"BPMN2.0 业务流程建模","content":"BPMN 2.0 业务流程建模01. BPMN定义\n\n\n\n\n\n\n\n\nOfficial Page: https://www.bpmn.org/\n由BPMI(The Business Process Management Initiative)开发了一套标准叫业务流程建模符号(BPMN - Business Process Modeling Notation)。在 BPMI Notation Working Group超过2年的努力，于2004年5月对外发布了BPMN 1.0 规范。后BPMI并入到OMG组织，OMG于2011年推出BPMN2.0标准，对BPMN进行了重新定义(Business Process Model and Notation)。\nBPMN（Business Process Modeling Notation，即业务流程建模符号），是一种流程建模的通用和标准语言，用来绘制业务流程图，以便更好地让各部门之间理解业务流程和相互关系。\n02. BPMN基础元素BPMN 2.0 只要充分了解以下四类基础元素，基本就能掌握BPMN 2.0 的核心：\n\n流对象\n数据\n连接对象\n泳道\n\n1. 流对象流对象（Flow Objects）：是定义业务流程的主要图形元素，包括三种：事件、活动、网关\n\n事件（Events）：指的是在业务流程的运行过程中发生的事情，分为：\n开始：表示一个流程的开始中间：发生的开始和结束事件之间，影响处理的流程结束：表示该过程结束\n\n活动（Activities）：包括任务和子流程两类。子流程在图形的下方中间外加一个小加号（+）来区分。\n\n网关（Gateways）：用于表示流程的分支与合并。\n排他网关：只有一条路径会被选择并行网关：所有路径会被同时选择包容网关：可以同时执行多条线路，也可以在网关上设置条件事件网关：专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件。当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。\n2. 数据数据（Data）：数据主要通过四种元素表示\n\n数据对象（Data Objects）\n数据输入（Data Inputs）\n数据输出（Data Outputs）\n数据存储（Data Stores）\n\n3. 连接对象连接对象（Connecting Objects）：流对象彼此互相连接或者连接到其他信息的方法主要有三种\n顺序流：用一个带实心箭头的实心线表示，用于指定活动执行的顺序\n信息流：用一条带箭头的虚线表示，用于描述两个独立的业务参与者（业务实体&#x2F;业务角色）之间发送和接受的消息流动\n关联：用一根带有线箭头的点线表示，用于将相关的数据、文本和其他人工信息与流对象联系起来。用于展示活动的输入和输出\n4. 泳道泳道（Swimlanes）：通过泳道对主要的建模元素进行分组，将活动划分到不同的可视化类别中来描述由不同的参与者的责任与职责。\n案例实例1：拍卖服务BPMN模板\n实例2：书籍销售流程 BPMN\n","slug":"bpmn","date":"2022-08-17T07:00:58.000Z","categories_index":"","tags_index":"BPMN","author_index":"Stephen Ling"},{"id":"a6fa10651f3de9f430ea08e410cd59bc","title":"事件流程链（EPC）建模指南","content":"事件流程链（EPC）建模指南什么是EPC?EPC全称事件驱动流程链Event-driven Process Chain，是在1990年代初期由萨尔兰德大学的Wilhelm-August Scheer教授在ARIS框架内开发的。EPC认为流程是由一系列事件触发的，并且针对事件的行为又将引发新的事件。因此，流程通常是事件-功能-事件的形式。\nEPC 模型通过将业务过程中的静态资源（系统、组织、数据等）组织在一起形成一个能够完成特定任务或者流程的动态模型。\nEPC流程图比较合适描述那些有严密过程控制和结果导向的流程。作为一种流程建模标准，只要满足这些规则限制，则能确保流程图的正确、表意清晰，从而指导业务开展。\n\nEPC组件说明\n事件（Event）事件是环境的一种特定状态，当环境改变到这种状态时，相应的流程就被触发了。通常也可以理解为现实世界的事物的某种状态的改变，用六边形表示，常见的三种情况：\n能触发某个流程开始的外部改变（比如：客户订单到达）流程内部处理状态的改变（比如：产品制造完毕）带来外部影响的结果（比如：订单送到客户手中）使用要点：\n事件可以是某人为事件或者是计算机系统操作的结果；事件通常采用主谓结构词组描述，比如：订单到达、成本计算完成；\n功能（Function）\n功能表示业务流程中的某个行为或者完成特定任务的活动。用圆角矩形表示。\n使用要点：\n通常，流程中的每一个活动都应该是一个增值过程；功能可能由人或者计算机系统完成；每一个功能都包含有输入，经过处理创造输出；功能的描述，通常采用动宾短语来表示，比如：输入订单、计算成本，应当避免使用模糊的单个动词来表达。\n规则（Logical Connectors）\n或者直接翻译为逻辑连接，包括：与（AND）、或（OR）、异或（XOR）。\n与（AND）同时激活流程中的所有路径，用“Λ”表示。\n或（OR）激活流程中的一个或多个路径，用“V”表示。\n异或（XOR）同一时间仅激活流程中的一条路径，用“XOR”表示。\n信息&#x2F;资源（Information Resource）\n信息&#x2F;材料代表来⾃现实世界的信息、材料或资源对象，它们可以是功能的输入，也可以是功能的输出。用矩形表示。\n组织单位（Organization Unit）\n组织单位意愿决定了企业结构中的哪个⼈或组织负责的特定职能。\n流程路径（Process Path）\n流程路径形状显⽰与其他流程的连接。\n系统 （System）承载某一流程的信息系统。\n流（Flow）、分配（Assignment）流（Flow）包含信息流（Information Flow）和控制流（Control Flow），前者用于系统、数据和功能之间的连接，表达信息的输入输出，后者用于事件、功能之间的连接，表达事件行为之间的驱动关系。\n在有的工具中，用带箭头的实线和虚线区分了信息流和控制流的表达，但是也有的工具中并没有进行这样的区分。\n分配（Assignment）用于功能、组织单位之间的连接，用不带箭头的实线表示。\nEPC建模注意点一般注意点\n\n每个事件驱动的流程链的开始和结束总是由一个事件来说明。\n每一个模型必须至少包含有一个开始事件和一个结束事件。\n功能与事件总是交替着出现。\n时间和功能永远只有一个输入和一个输出连接。\n流程路径使用规则进行分离与合并。\n功能的多事件触发也是通过规则表达。\n避免在事件之后使用OR和XOR，尽量使用功能来作出决策。\n凡是做出了某种决策的功能，后面总是紧跟着规则。\n通过规则体现某个决策之后的各种可能路径。\n紧跟在规则之后的事件，体现了决策的一种可能结果。\n规则不能同时有多个输入和输出。\n尽量避免组合使用规则，这样会难以理解。\n在功能之后，除非清楚知道多分支结果事件会同时发生才用OR，否则尽量采用XOR。\n分支和合并通常使用同一个规则，如果要合并分支，在事件之后合并会更容易理解。\n\n规则注意点\n\n每个事件可以跟随多个功能，也可以每个功能跟随多个事件，但两者之间存在规则。\n\n\n案例铁路货运流程链\n订单流程链\n","slug":"epc","date":"2022-08-16T08:25:45.000Z","categories_index":"","tags_index":"EPC,Business Operation","author_index":"Stephen Ling"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-08-16T08:21:58.290Z","categories_index":"","tags_index":"","author_index":"Stephen Ling"},{"id":"12fc428b925e85ceda270bf3ebacf160","title":"BrickLayer - 搬瓦工 认证授权模块","content":"认证授权模块模块需求\n签发JWT TOEKN进行认证和授权\n支持Gitlab, AD登录\n支持ABAC权限校验\n\n什么是SSO?利用JWTtoken完成SSO的技术要求\nSSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。\n什么OAuth2.0?","slug":"projects/bricklayer/auth","date":"2022-08-14T04:28:30.000Z","categories_index":"","tags_index":"SSO,Authentication,Authorization,Devops,Bricklayer","author_index":"Stephen Ling"},{"id":"d8b335f53a173a866d08f7112a86fc25","title":"BrickLayer - 搬瓦工","content":"BrickLayer - 搬瓦工 设计需求\n 项目管理\n 环境管理\n 配置管理\n\n\n CICD管理\n 应用监控\n 部署报告\n 测试报告\n\n\n 基础设施管理\n kubernetes\n openstack\n baremetal\n\n\n 仓库管理\n 代码仓库\n gitlab\n github\n\n\n 镜像仓库\n harbor\n\n\n\n\n 账户管理\n OAUTH2\n 多租户\n\n\n\n设计技术栈\nKubernetes - 底座\nRust - 编程语言\nTekton - CI pipeline\nArgoCD - CD tools\nArgoEvent - 事件处理\nArgoWorkflow - 工作流\nIstio - 网管&#x2F;流量管理\nNacos - 配置分发中心\n\n","slug":"projects/bricklayer/design","date":"2022-08-12T08:33:42.000Z","categories_index":"","tags_index":"Devops,Bricklayer","author_index":"Stephen Ling"},{"id":"9340bb342c42221aa9c7ffe9155e75d9","title":"小表驱动大表","content":"小表驱动大表什么是小表驱动大表?用小的数据集去驱动(匹配)大的数据集\n为什么需要小表驱动大表\n小表驱动大表\nselect *from tb_emp_bigdata A where A.deptno in (select B.deptno from tb_dept_bigdata B)\n\n大表驱动小表\nselect * from tb_dept_bigdata A where A.deptno in(select B.deptno from tb_emp_bigdata B);\nselect * from tb_dept_bigdata A where A.deptno exists(select 1 from tb_emp_bigdata B where B.deptno&#x3D;A.deptno);\n\n小表驱动大表的主要目的是通过减少表连接创建的次数,加快查询速度.\n","slug":"database/less-drive-more","date":"2022-08-12T02:38:58.000Z","categories_index":"","tags_index":"SQL","author_index":"Stephen Ling"},{"id":"68f0bef26795408fddf21d88ca9001c0","title":"OpenGL - Hello, Triangle","content":"OpenGL - Hello, Triangle所有东西在OpenGL内都是三维的, 但是屏幕或窗口是2d的。所以所有坐标都需要由3D转为2D坐标。这个转换过程成为管线(pipeline)。这里面分为两大步，第一步坐标转换，第二步将坐标转为像素点绘图。\n这些步骤都是高度分化的，所以很容易并行执行。GPU有很多的小单元所以很适合去并行执行这些任务，这些小单元上运行的程序则称为shader(着色器)。\n着色器用GLSL控制。\nPipelinesVertex Data -&gt; Shape Assembly -&gt; Geometry Shader -&gt; Rasterization(光栅化) -&gt; Fragment Shader -&gt; Test and Blending\n编写代码\n#include &lt;glad&#x2F;glad.h&gt;\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\n#include &lt;iostream&gt;\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height);\nvoid process_keyboard_input(GLFWwindow *window);\n\n&#x2F;&#x2F; shader written in GLSL\nconst char *vertexShaderSource &#x3D; &quot;#version 330 core\\n&quot;\n                                 &quot;layout (location &#x3D; 0) in vec3 aPos;\\n&quot;\n                                 &quot;void main()\\n&quot;\n                                 &quot;&#123;\\n&quot;\n                                 &quot;   gl_Position &#x3D; vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;\n                                 &quot;&#125;\\0&quot;;\n\nconst char *fragmentShaderSource &#x3D; &quot;#version 330 core\\n&quot;\n                                   &quot;out vec4 FragColor;\\n&quot;\n                                   &quot;void main()\\n&quot;\n                                   &quot;&#123;\\n&quot;\n                                   &quot;    FragColor &#x3D; vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot;\n                                   &quot;&#125;\\0&quot;;\n\nint main(void)\n&#123;\n\n    &#x2F;&#x2F; 初始化glfw\n    GLFWwindow *window;\n    int w_width &#x3D; 1920, w_height &#x3D; 1080;\n\n    if (!glfwInit())\n    &#123;\n        std::cout &lt;&lt; &quot;failed to init glfw&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;\n\n    window &#x3D; glfwCreateWindow(1920, 1080, &quot;cube&quot;, NULL, NULL);\n    if (!window)\n    &#123;\n        std::cout &lt;&lt; &quot;failed to create window&quot; &lt;&lt; std::endl;\n        glfwTerminate();\n        return -1;\n    &#125;\n\n    &#x2F;&#x2F; 创建上下文\n    glfwMakeContextCurrent(window);\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    &#123;\n        std::cout &lt;&lt; &quot;failed to init glad&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;\n\n    &#x2F;******************************\n              shader part\n    *******************************&#x2F; \n\n    &#x2F;&#x2F; vertex shader\n    unsigned int vertexShader;\n    vertexShader &#x3D; glCreateShader(GL_VERTEX_SHADER);\n    &#x2F;&#x2F; 编译Vertex shader\n    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);\n    glCompileShader(vertexShader);\n\n    &#x2F;&#x2F; fragment shader\n    unsigned int fragmentShader;\n    fragmentShader &#x3D; glCreateShader(GL_FRAGMENT_SHADER);\n    &#x2F;&#x2F; 编译Fragment shader\n    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);\n    glCompileShader(fragmentShader);\n\n    &#x2F;&#x2F; shader\n    unsigned int shaderProgram;\n    shaderProgram &#x3D; glCreateProgram();\n    glAttachShader(shaderProgram, vertexShader);\n    glAttachShader(shaderProgram, fragmentShader);\n    glLinkProgram(shaderProgram);\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    &#x2F;***********************\n          triangle part\n    ***********************&#x2F;\n\n    &#x2F;&#x2F; 定义三角形顶点\n    float vertexArray[] &#x3D; &#123;\n        0.5, -0.5, 0,\n        -0.5, -0.5, 0,\n        0, 0.5, 0,\n    &#125;;\n\n    &#x2F;&#x2F; 存储分配到的id\n    unsigned int VBO, VAO;\n    glGenVertexArrays(1, &amp;VAO);\n    glGenBuffers(1, &amp;VBO);\n\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexArray), vertexArray, GL_STATIC_DRAW);\n\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0); \n\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;&#x2F; 处理键盘事件\n        process_keyboard_input(window);\n\n        glClearColor(0.2, 0.4, 0.6, 1.0);\n\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;&#x2F; use our shader program when we want to render an object\n        glUseProgram(shaderProgram); &#x2F;&#x2F; 不使用，则上默认色\n        glBindVertexArray(VAO);\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n\n        glfwSwapBuffers(window);\n\n        glfwPollEvents();\n    &#125;\n\n    glDeleteVertexArrays(1, &amp;VAO);\n    glDeleteBuffers(1, &amp;VBO);\n    glDeleteProgram(shaderProgram);\n\n    glfwTerminate();\n    return 0;\n&#125;\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height)\n&#123;\n    glfwMakeContextCurrent(window);\n    glViewport(0, 0, width, height);\n&#125;\n\nvoid process_keyboard_input(GLFWwindow *window)\n&#123;\n    if (glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS)\n    &#123;\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    &#125;\n&#125;\n\n结果截图\n","slug":"computer-graphics/opengl/opengl-04","date":"2022-08-07T13:37:47.000Z","categories_index":"","tags_index":"ComputerGraphics,OpenGL,C++","author_index":"Stephen Ling"},{"id":"28d97a9714322db76ed5f13f13ad12ec","title":"OpenGL - Creating a window","content":"Creating a window创建窗口是第一步，然而OpenGL仅仅是定义了一系列关于窗口的操作api，而这些操作api实际执行和操作系统和硬件都有很大关系。这也意味着开发者必须自己处理这些问题。\n不过，幸运的是我们可以使用一些库来避免自己处理这些问题。例如GLUT,GLFW,SDL,SFML等。\nGLFWUbuntu下安装\n# 安装opengl、glfw、glew库\nsudo apt install libglfw3 libglfw3-dev libopengl-dev libglew2.2 libglew-dev\n\n\nGLAD除了GLFW来帮助解决窗口外，还需要使用GLAD解决函数指针问题。OpenGL仅仅是一套标准，有大量需要使用的函数在写代码时候是不确定其实际位置的(和驱动相关)，所以需要通过查找函数名的方式来确定其运行时地址。\n打开glad官网\n\n将下载好的glad.c文件拷贝到项目目录, glad和KHR文件夹复制到&#x2F;usr&#x2F;local&#x2F;include&#x2F;目录下\n编写代码#include &lt;glad&#x2F;glad.h&gt;\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\n#include &lt;iostream&gt;\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height);\nvoid process_keyboard_input(GLFWwindow *window);\n\nint main(void)\n&#123;\n\n    &#x2F;&#x2F; 初始化glfw\n    GLFWwindow *window;\n    int w_width &#x3D; 1920, w_height &#x3D; 1080;\n\n    if (!glfwInit())\n    &#123;\n        std::cout &lt;&lt; &quot;failed to init glfw&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;\n\n    window &#x3D; glfwCreateWindow(1920, 1080, &quot;cube&quot;, NULL, NULL);\n    if (!window)\n    &#123;\n        std::cout &lt;&lt; &quot;failed to create window&quot; &lt;&lt; std::endl;\n        glfwTerminate();\n        return -1;\n    &#125;\n\n    &#x2F;&#x2F; 创建上下文\n    glfwMakeContextCurrent(window);\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    &#123;\n        std::cout &lt;&lt; &quot;failed to init glad&quot; &lt;&lt; std::endl;\n        return -1;\n    &#125;\n\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;&#x2F; 处理键盘事件\n        process_keyboard_input(window);\n\n        glClearColor(0.2, 0.4, 0.6, 1.0);\n\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;&#x2F; 设置点信息\n        glPointSize(10);\n        glColor3ub(125, 255, 255);\n        \n        &#x2F;&#x2F; 画三个点,平面坐标范围是(-1, 1)\n        glBegin(GL_POINTS);\n        glVertex3f(0, 0, 0);\n        glVertex3f(0.5, 0, 0);\n        glVertex3f(-0.5, 0, 0);\n        glEnd();\n\n        glfwSwapBuffers(window);\n\n        glfwPollEvents();\n    &#125;\n\n    glfwTerminate();\n    return 0;\n&#125;\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height)\n&#123;\n    &#x2F;&#x2F; 改变绘图区域\n    glfwMakeContextCurrent(window);\n    glViewport(0, 0, width, height);\n&#125;\n\nvoid process_keyboard_input(GLFWwindow *window) &#123;\n    &#x2F;&#x2F; 检测到esc就关闭窗口\n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) &#x3D;&#x3D; GLFW_PRESS) &#123;\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    &#125;\n&#125;\n\n验证c++ main.cpp glad.c -o main -lgl -lglfw \n.&#x2F;main\n\n结果截图\n","slug":"computer-graphics/opengl/opengl-03","date":"2022-08-07T08:46:26.000Z","categories_index":"","tags_index":"ComputerGraphics,OpenGL,C++","author_index":"Stephen Ling"},{"id":"53754339a6fb973dc05deaeaa99e1d0f","title":"OpenGL - What is OpenGL?","content":"What is OpenGL?OpenGL is mainly considered an API (an Application Programming Interface) that provides us with a large set of functions that we can use to manipulate graphics and images. However, OpenGL by itself is not an API, but merely a specification, developed and maintained by the Khronos Group.\nWhat is Khronos Group?Khronos Group团队成立于 2000 年 1 月，由包括 3Dlabs, ATI, Discreet, Evans &amp; Sutherland, Intel, Nvidia, SGI 和 Sun Microsystems 在内的多家国际知名多媒体行业领导者创立，致力于发展开放标准的应用程序接口 API ，以实现在多种平台和终端设备上的富媒体创作、加速和回放。\nCore-profile vs Immediate mode\n\n\n\n\n\n\n\n\n摘录自Opengl的核心模式与立即渲染模式\n早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。\n立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。\nExtensionsOpenGL支持直接使用拓展，有时候图形厂商可能在驱动中提供了新特性(更高效或便捷)，而这些特性不存在现有OpenGL中。但是照样可以通过拓展方式去使用他们，这样就无需等待OpenGL的新版本支持。如果此类特性足够流行好用，OpenGL也会在新版本中支持他们。\nif(GL_ARB_extension_name)   &#x2F;&#x2F; 拓展名\n&#123;\n    &#x2F;&#x2F; Do cool new and modern stuff supported by hardware\n&#125;\nelse\n&#123;\n    &#x2F;&#x2F; Extension not supported: do it the old way\n&#125;\n\nState MachineOpenGL采用状态机编程。用一系列变量描述OpenGL当前状态，通常这些状态集合，我们称为OpenGL上下文。\nObjectsOpenGL库是由C编写，同时有其他语言的派生版本。但是其核心仍然是C编写的，由于C无法很好地转换为其他语言，所以在OpenGL中抽象了很多结构来应对这个问题。 Objects就是其中一种抽象结构。一个object就是一系列OpenGL状态的集合\n","slug":"computer-graphics/opengl/opengl-02","date":"2022-08-07T07:32:29.000Z","categories_index":"","tags_index":"ComputerGraphics,OpenGL,C++","author_index":"Stephen Ling"},{"id":"400c2cc982fad3284e2cd765c0295fa5","title":"OpenGL - setting up","content":"OpenGL - setting upplatform: Ubuntu 22.04\nInstalling GLFW + OpenGL + GLEW# 安装opengl、glfw、glew库\nsudo apt install libglfw3 libglfw3-dev libopengl-dev libglew2.2 libglew-dev\n\nValidating installation&#x2F;*\n * @Author: shiyun.ling shiyun.ling@flexiv.com\n * @Date: 2022-07-26 23:27:12\n * @LastEditors: shiyun.ling\n * @LastEditTime: 2022-07-26 23:27:29\n * @Description: file content\n *&#x2F;\n\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\nint main(void)\n&#123;\n    GLFWwindow* window;\n\n    &#x2F;* Initialize the library *&#x2F;\n    if (!glfwInit())\n        return -1;\n\n    &#x2F;* Create a windowed mode window and its OpenGL context *&#x2F;\n    window &#x3D; glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL);\n    if (!window)\n    &#123;\n        glfwTerminate();\n        return -1;\n    &#125;\n\n    &#x2F;* Make the window&#39;s context current *&#x2F;\n    glfwMakeContextCurrent(window);\n\n    &#x2F;* Loop until the user closes the window *&#x2F;\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;* Render here *&#x2F;\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;* Swap front and back buffers *&#x2F;\n        glfwSwapBuffers(window);\n\n        &#x2F;* Poll for and process events *&#x2F;\n        glfwPollEvents();\n    &#125;\n\n    glfwTerminate();\n    return 0;\n&#125;\n\nPreview of code\n","slug":"computer-graphics/opengl/opengl-01","date":"2022-07-26T14:37:56.000Z","categories_index":"computer-graphics,opengl","tags_index":"ComputerGraphics,OpenGL,C++","author_index":"Stephen Ling"},{"id":"981bde0bdc29624ee6b4b6ebc6cc7ab4","title":"Computer Graphics CMU 15-462/662 lecture 01","content":"Lecture 01\n\n\n\n\n\n\n\n\nvideo: Lecture 01\nNames of cg journeySIGGRAPH\nObjectives of this course\nTo figure out what cg is\nImplement 1st algorithm to make images of 3D shapes\n\nWhat Computer Graphics is ?\nThe use of computers to synthesize visual information.\n\nThe use of computers to synthesize and manipulate sensory information.\n\nTurn digital information into physical matter\n\n\nConclusion: CG is everywhere!!!\nHistory of computer graphicsSketchpad(1963) - first time to think about cg\n8k monitor \nvr headset 2x2160x2160@90HZ &#x3D;&gt; 2.3GB&#x2F;s\nWhy visual important?For human beings, about 30% of brain dedicated to visual processing.\nFoundations of computer graphics\nSophisitcated theory &amp; systems\nTheory\nbasic representations基础图形表示\nsampling &amp; aliasing 采样 模拟信号\nnumerical methods 信号处理\nradiometry &amp; light transport 光照\nperception 预测\n\n\nSystems\nparallel 并行处理\ngraphics-specific programming languages 图形编程语言\n\n\n\n1st 3D shapes algorithmModeling and drawing a cubeModeling\ncentered at the origin (0,0,0)\n2x2x2 dimensions\nedges are aligned with x&#x2F;y&#x2F;z axes\n\n1.Verticles (8 points)A: (-1, 1, 1)    E:(-1, -1, 1)\nB: (1, 1, 1)     F:(1, -1, 1)\nC: (1, 1, -1)    G:(1, -1, -1)   \nD: (-1, 1, -1)   H:(-1, -1, -1)\n\n2.EdgesAE, AB, AD\nEF. EH\nCB, CG, CD\nGH, GF\nBF\nDH\n\n3.Perspective ProjectionPinhole model of a camera(X,Y,Z) -&gt; (x,y,z) -&gt; (u,v)\nRendering with OpenGL&#x2F;*  verticles\n    A: (-1, 1, 1)    E:(-1, -1, 1)\n    B: (1, 1, 1)     F:(1, -1, 1)\n    C: (1, 1, -1)    G:(1, -1, -1)   \n    D: (-1, 1, -1)   H:(-1, -1, -1)\n\n    edges\n    AE, AB, AD\n    EF. EH\n    CB, CG, CD\n    GH, GF\n    BF\n    DH\n*&#x2F;\n\n\n\n","slug":"computer-graphics/cmu-courses/01","date":"2022-07-26T13:13:09.000Z","categories_index":"computer-graphics,cmu-courses","tags_index":"ComputerGraphics","author_index":"Stephen Ling"},{"id":"7d689785198fd8b3dd56655e8c46e576","title":"Gitops Best Practice","content":"Gitops Best PracticePre-requisuites\na kubernetes cluster\n\nOptional\nrancher 集群管理界面\nkubevious 集群管理界面\n\nRequirements\ngitlab 仓库\nharbor 镜像仓库\ntekton 流水线\nargo rollout 渐进式\nistio 网关\n\nRancher (不推荐，容易崩溃，界面老旧)可视化集群管理界面\nInstallationhelm repo add rancher-latest https:&#x2F;&#x2F;releases.rancher.com&#x2F;server-charts&#x2F;latest\n\nkubectl create namespace cattle-system\n\nkubectl apply -f https:&#x2F;&#x2F;github.com&#x2F;cert-manager&#x2F;cert-manager&#x2F;releases&#x2F;download&#x2F;v1.7.2&#x2F;cert-manager.crds.yaml\n\nhelm repo add jetstack https:&#x2F;&#x2F;charts.jetstack.io\n\nhelm repo update\n\nhelm install cert-manager jetstack&#x2F;cert-manager \\\n  --namespace cert-manager \\\n  --create-namespace \\\n  --version v1.7.1\n\nhelm install rancher rancher-latest&#x2F;rancher \\\n  --namespace cattle-system \\\n  --set hostname&#x3D;rancher.sslip.io \\\n  --set replicas&#x3D;1 \\\n  --set bootstrapPassword&#x3D;password\n\n将rancher.sslip.io注册进dns中，打开浏览器进行访问.\n\nGitlab可自托管git版本控制系统\nInstallationhelm repo add gitlab https:&#x2F;&#x2F;charts.gitlab.io&#x2F;\nhelm install -n gitlab --create-namespace gitlab gitlab&#x2F;gitlab --set certmanager.email&#x3D;email@example.com\n\nRoot Inital Secretkubectl get -n gitlab secret  ","slug":"cloud-native/gitops-best-practice","date":"2022-07-25T08:02:33.000Z","categories_index":"cloud-native","tags_index":"Kuberetes,CloudNative","author_index":"Stephen Ling"},{"id":"a65dcaaafc431efe347de1d9e1ae0f86","title":"Gitops - ArgoCD vs FluxCD","content":"ArgoCD vs FluxCD比较ArgoCD和FluxCD之前，我们应该先了解一下Gitops\nGitops的基础思想是，将环境放入版本控制系统并通过一个自动流程确保我们的代码运行在代码仓库中描述的状态。\n\n\n\n\nArgoCD\nFluxCD\n\n\n\n\n声明式CD工具，可弹性扩展，自带安全管理，支持SSO，多集群多租户。\n最初由WeaveWorks开发，现由CNCF托管。Flux支持持续部署和渐进式部署。\n\n\n声明方式\nGit,Helm,Kustomize,Jsonnet\nGit,Helm\n\n\n安全策略\nOAuth2, RBAC\nRBAC\n\n\n回滚\n支持\n不支持\n\n\n同步方式\n持续部署\n持续部署,渐进式部署\n\n\n通知\nwebhook, alertmanager, email, grafana, slack, teams, telegram, pushover, github, google chat, pushover, mattermost\nalertmanager, azureeventhub, discord, generic, githubdispatch, googlechat, grafana, lark, matrix, teams, opsgenie, rocket, sentry, slack, telegram, webex, azuredevops, bitbucket, github, gitlab\n\n\nWeb界面\n支持\n不支持\n\n\n","slug":"cloud-native/fluxcd","date":"2022-07-25T02:57:03.000Z","categories_index":"cloud-native","tags_index":"Kuberetes,CICD","author_index":"Stephen Ling"},{"id":"701588241f5ca3e17bd8d90ee80a988d","title":"Grafana + Loki + Promtail + Prometheus + Traefik - 监控服务指标以及日志告警","content":"监控服务指标以及日志告警\n\n\n\n\n\n\n\n\n示例仓库地址: Github\n通过收集服务日志以及服务指标，设置相应的监控规则，监控服务响应异常，网络异常，磁盘异常等。\n做到及时响应的同时，快速定位问题。\n0. 国内防火墙问题将PROXY传入k3s容器内，同时配置docker daemon的PROXY.可以解决大部分容器内翻墙需求。\nk3d cluster create --env &quot;HTTP_PROXY&#x3D;$&#123;HOST_IP&#125;@server:*&quot; --env &quot;HTTPS_PROXY&#x3D;$&#123;HOST_IP&#125;@server:*&quot; ...\n\n\n1. 编写一个简单的服务这里使用fastapi去编写一个简单的服务，这个服务提供四个接口,分别返回200,400,404,500。\n# server.py\n\nfrom fastapi import FastAPI\nfrom fastapi.responses import Response\n\napp &#x3D; FastAPI()\n\n\n@app.get(&quot;&#x2F;200&quot;)\nasync def return200():\n    return Response(content&#x3D;&quot;OK&quot;)\n\n\n@app.post(&quot;&#x2F;400&quot;)\nasync def return400():\n    return Response(content&#x3D;&quot;Bad Request&quot;, status_code&#x3D;400)\n\n\n@app.get(&quot;&#x2F;404&quot;)\nasync def return404():\n    return Response(content&#x3D;&quot;Not Found&quot;, status_code&#x3D;404)\n\n\n@app.get(&quot;&#x2F;500&quot;)\nasync def return500():\n    return Response(content&#x3D;&quot;Internal Server Error&quot;, status_code&#x3D;500)\n\n\n2. 搭建Grafanahelm install grafana grafana&#x2F;grafana\n\n3. 搭建Lokihelm install loki grafana&#x2F;loki\n\n4. 搭建Promtailhelm install promtail grafana&#x2F;promtail\n\n5. 搭建prometheushelm repo add prometheus-community https:&#x2F;&#x2F;prometheus-community.github.io&#x2F;helm-charts\nhelm repo update\nhelm install prometheus prometheus-community&#x2F;prometheus\n\n6. 搭建Grafana仪表盘\n","slug":"cloud-native/grafana","date":"2022-07-20T07:46:39.000Z","categories_index":"cloud-native","tags_index":"CloudNative,Grafana,Loki,Promtail,Prometheus,Traefik","author_index":"Stephen Ling"},{"id":"4ca1f34c3818e2813c915142c2347359","title":"K8S - Endpoint","content":"K8S Endpoint作用Endpoint用于定义服务入口，这个入口既可以是k8s内部服务，也可以是外部服务。Endpoint一般和Service一起配套使用。\n当Service通过selector绑定deployment或者statefulset时，都会自动生成一份相同名字的Endpoint。但是当管理外部服务的时候，就需要我们自己手动创建了。\n手动管理Endpoint的使用场景考虑到K8S调度有状态服务的能力，以及涉及到一些特殊硬件设备的服务，一般他们都会被部署到外部独立管理，所以为了用集群的能力去管理则需要Endpoint去管理他们。\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-service\nspec:\n  ports:\n    - name: web\n      port: 80 \n      targetPort: 80 # 非必须\n---\napiVersion: v1\nkind: Endpoint\nmetadata:\n  name: external-service\nspec:\n  addresses:\n    - ip: xxx.xxx.xxx.xxx\n  ports:\n    - name: web  # 此处必须和Service中定义的保持一致\n      port: 80   # 此处必须和Service中定义的保持一致\n","slug":"cloud-native/k8s-endpoint","date":"2022-07-19T15:42:05.000Z","categories_index":"cloud-native","tags_index":"Kubernetes","author_index":"Stephen Ling"},{"id":"268900bf172135516a6461e1227a0474","title":"Tekton 云原生CICD流水线","content":"Tekton核心概念Step - 步骤一个步骤代表一个容器，去执行命令并输出结果\nsteps:\n  - name: deploy-app\n  \timage: foo&#x2F;base-image:2.7\n\tenv:\t\n\t  - name: API_KEY\n\t    valueFrom: \n\t\t  secretKeyRef:\n\t\t    name: secure-properties\n\t\t\tkey: apiKey\n\tscript: |\n\t  cloud login -a $(params.api-url)\n\nTask - 任务一个任务代表一系列步骤的集合\napiVersion: tekton.dev&#x2F;v1beta1\nkind: Task\nmetadata:\n  name: deploy-to-my-awesome-cloud\nspec:\n  params:\n  \t- name: api-url\n\t  default: cloud.com\n  steps:\n    - name: deploy-app\n\t  image: foo&#x2F;base-image:2.7\n\t  env:\t\n\t    - name: API_KEY\n\t\t  valueFrom: \n\t\t    secretKeyRef:\n\t\t\t  name: secure-properties\n\t\t\t  key: apiKey\n\t  script: |\n\t    cloud login -a $(params.api-url)\n\nPipeline - 流水线一条流水线代表一系列任务的集合\napiVersion: tekton.dev&#x2F;v1beta1\nkind: Pipeline\nmetadata:\n  name: project-pipeline\nspec:\n  params:\n    - name: api-url\n\t- name: cloud-region\n  tasks:\n    - name: clone\n\t  taskRef:\n\t    name: git-clone\n    - name: build\n\t  taskRef:\n\t    name: build\n\t  runAfter:\n\t  \t- clone\n\t- name: deploy\n\t  taskRef:\n\t    name: deploy\n      runAfter:\n\t  \t- build","slug":"cloud-native/tekton","date":"2022-07-17T18:07:55.000Z","categories_index":"cloud-native","tags_index":"CloudNative,Tekton,Pipeline","author_index":"Stephen Ling"},{"id":"44e4ec9f11dd82491daf05435d1368ad","title":"服务网格","content":"服务网格什么是服务网格?服务网格（例如开源项目 Istio）用于控制应用的不同部分之间如何共享数据。与用于管理此类通信的其他系统不同，服务网格内置于应用程序中的专用基础架构层。这个可见的基础架构层可以记录应用的不同部分是否能正常交互。因此，随着应用的不断发展，它在优化通信和避免停机方面就显得更加有用。\n应用的每个部分——即”服务”，都要与其他服务相互协作，来为用户提供所需的内容。如果在线零售应用的用户想购买什么东西，他们得知道该商品是否有货。因此，负责与公司库存数据库通信的服务需要与产品网页进行通信，而产品网页本身，也需要与用户的在线购物车通信。为了增加业务价值，该零售商之后可能会推出一项新服务：在应用中为用户提供产品推荐。要推荐产品，这项新服务除了要与产品标签数据库进行通信外，还需要与产品页面所需的同一个库存数据库进行通信，因此这涉及到大量可重复使用的移动组件。\n现代应用常以这种方式拆分，所有组件构成一个服务网络，每一个都分别执行特定的业务功能。要执行相应的功能，一项服务可能需要向其他几项服务请求数据。但如果有些服务（例如零售商的库存数据库）遇到请求超载会怎样呢？这就要靠服务网格了，它会将请求从一项服务路由到下一项，从而优化所有移动组件的协同工作方式。\n服务网格的关键因素\n可靠性  服务网格通过边车代理，保证容器、服务之间通信的高效和可靠\n可见性  服务网格提供服务健康检查和行为监控。控制平面可以收集并统计服务的运行情况，包括服务的网络时延、网络状况、分布式追踪和日志。通常可以用到的工具有Prometheus,Elasticsearch,Grafana等\n安全  服务网格可以自动加密服务间通信，执行分布式安全策略\n\n服务网格的优点和劣势优点\n简化服务间通信给传统业务编码带来的不必要管理成本\n更容易诊断通信错误\n更容易实现安全，支持加密通信、鉴权和授权\n更快测试、发布、开发\n通过边车模式更加高效管理网络通信\n\n劣势\n运行服务网格本身需要增加服务运营成本\n增加了通信成本，因为每个服务都需要经由一个边车代理\n服务网格无法处理和其他服务和系统、传输转换等问题\n增加了管理成本。网络管理本身非常抽象困难且无法避免，团队中必须有人需要将服务网格适配进工作任务以及管理其配置\n\n常见服务网格\n\n\n\n\n\n\n\n\n[CNCF Service Mesh Survey 2020]https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf\n\nAWS App Mesh\nAzure Service Fabric Mesh\nBuoyant Conduit\nF5 Nginx Service Mesh\nGoogle Anthos Service Mesh\nHashiCorp Consul\nIstio\nKong Mesh\nKuma\nLinkerd\nRed Hat OpenShift Service Mesh\nGloo Mesh\nTetrate\nTigera Calico Cloud\nTraefik Labs\nVMware Tanzu Service Mesh\n\n","slug":"cloud-native/service-mesh","date":"2022-07-17T18:04:02.000Z","categories_index":"cloud-native","tags_index":"CloudNative,ServiceMesh","author_index":"Stephen Ling"},{"id":"3b63f2fddd88d6903dbde299ee7b6a3e","title":"istio 从入门到入土","content":"Istio 从入门到入土流量管理Istio 的流量路由规则可让您轻松控制服务之间的流量和 API 调用。Istio 简化了断路器、超时和重试等服务级别属性的配置，并可以轻松设置重要任务，例如 A&#x2F;B 测试、金丝雀发布和基于百分比的流量拆分的分阶段发布。它还提供开箱即用的可靠性功能，帮助您的应用程序更灵活地应对依赖服务或网络的故障。\nIstio 的流量管理模型依赖于使者 与您的服务一起部署的代理。您的网格服务发送和接收的所有流量（数据平面流量）通过 Envoy 代理，从而可以轻松地引导和控制网格周围的流量，而无需对服务进行任何更改。\n如果您对本指南中描述的功能如何工作的详细信息感兴趣，可以在 架构概述中找到有关 Istio 流量管理实现的更多信息。本指南的其余部分介绍了 Istio 的流量管理功能。\n虚拟服务最基础的路由功能单位，每个虚拟服务都会有一系列路由规则组成，istio会按顺序执行匹配这些规则来路由请求。\napiVersion: networking.istio.io&#x2F;v1alpha3\nkind: VirtualService\nmetadata:\n  name: reviews\nspec:\n  hosts:\n  - reviews\n  http:\n  - match:\n    - headers:\n        end-user:\n          exact: jason\n    route:\n    - destination:\n        host: reviews\n        subset: v2\n  - route:\n    - destination:\n        host: reviews\n        subset: v3\n\n目的规则目的地规则是在虚拟服务规则执行后，引导流量。例如可以定义你的多个版本的服务的实际路由规则\napiVersion: networking.istio.io&#x2F;v1alpha3\nkind: DestinationRule\nmetadata:\n  name: my-destination-rule\nspec:\n  host: my-svc\n  trafficPolicy:\n    loadBalancer:\n      simple: RANDOM\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n    trafficPolicy:\n      loadBalancer:\n        simple: ROUND_ROBIN\n  - name: v3\n    labels:\n      version: v3\n\n网关管理网格中出入流量，控制何种流量可以流出以及流入。网关配置只会应用给网格边缘运行的单节点Envoy代理，而不会发送给服务负载的Envoy边车代理。提供4-7层网络控制。通过网关配置egress规则，决定服务是否可以与外部通信，提供更高安全管控能力。\napiVersion: networking.istio.io&#x2F;v1alpha3\nkind: Gateway\nmetadata:\n  name: ext-host-gwy\nspec:\n  selector:\n    app: my-gateway-controller\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    hosts:\n    - ext-host.example.com\n    tls:\n      mode: SIMPLE\n      credentialName: ext-host-cert\n\n服务入口通过声明服务入口，可以像内部服务一样使用管理外部服务。你不需要为每个外部服务做此声明，但是这样将不能使用istio特性来控制这些服务的流量。\napiVersion: networking.istio.io&#x2F;v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: svc-entry\nspec:\n  hosts:\n  - ext-svc.example.com\n  ports:\n  - number: 443\n    name: https\n    protocol: HTTPS\n  location: MESH_EXTERNAL\n  resolution: DNS\n\n边车istio默认每个envoy代理接受并转发负载所有端口上的流量。你可以使用sidecar配置来达到以下效果:\n\n调优Envoy代理接受的端口和协议\n限制Envoy可以达到的服务apiVersion: networking.istio.io&#x2F;v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: bookinfo\nspec:\n  egress:\n  - hosts:\n    - &quot;.&#x2F;*&quot;\n    - &quot;istio-system&#x2F;*&quot;\n\n网络故障恢复和验证istio不仅提供了以上的流量管理能力，同样提供了动态可选的故障回复和错误注入特性。运用这些特性可以促成你的服务更加可靠。\n超时apiVersion: networking.istio.io&#x2F;v1alpha3\nkind: VirtualService\nmetadata:\n  name: ratings\nspec:\n  hosts:\n  - ratings\n  http:\n  - route:\n    - destination:\n        host: ratings\n        subset: v1\n    timeout: 10s\n\n重试apiVersion: networking.istio.io&#x2F;v1alpha3\nkind: VirtualService\nmetadata:\n  name: ratings\nspec:\n  hosts:\n  - ratings\n  http:\n  - route:\n    - destination:\n        host: ratings\n        subset: v1\n    retries:\n      attempts: 3\n      perTryTimeout: 2s\n\n熔断apiVersion: networking.istio.io&#x2F;v1alpha3\nkind: DestinationRule\nmetadata:\n  name: reviews\nspec:\n  host: reviews\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n    trafficPolicy:\n      connectionPool:\n        tcp:\n          maxConnections: 100\n\n\n通信安全支持TLS\n可见性\n属性envoy_cluster_internal_upstream_rq&#123;response_code_class&#x3D;&quot;2xx&quot;,cluster_name&#x3D;&quot;xds-grpc&quot;&#125; 7163\n\nenvoy_cluster_upstream_rq_completed&#123;cluster_name&#x3D;&quot;xds-grpc&quot;&#125; 7164\n\nenvoy_cluster_ssl_connection_error&#123;cluster_name&#x3D;&quot;xds-grpc&quot;&#125; 0\n\nenvoy_cluster_lb_subsets_removed&#123;cluster_name&#x3D;&quot;xds-grpc&quot;&#125; 0\n\nenvoy_cluster_internal_upstream_rq&#123;response_code&#x3D;&quot;503&quot;,cluster_name&#x3D;&quot;xds-grpc&quot;&#125; 1\n分布式跟踪\n日志\n\n拓展性","slug":"cloud-native/istio","date":"2022-07-17T17:59:14.000Z","categories_index":"cloud-native","tags_index":"CloudNative,istio,ServiceMesh","author_index":"Stephen Ling"}]